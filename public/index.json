[{"categories":null,"contents":"Lorem ipsum dolor sit amet, et essent mediocritatem quo, choro volumus oporteat an mei. ipsum dolor sit amet, et essent mediocritatem quo,\n","date":"0001-01-01T00:00:00Z","permalink":"https://goiw111.github.io/homepage/about/","section":"homepage","tags":null,"title":"Our Difference"},{"categories":null,"contents":"Introduction In electrical power systems, ensuring safety and reliability is critical, especially when dealing with high-voltage and three-phase configurations. A Core Balance Current Transformer (CBCT), also known as a Zero Sequence Current Transformer (ZCT), plays a pivotal role in protecting these systems from faults such as earth leakage, ground faults, and imbalances. This article delves into the principles, design, operation, applications, and advantages of CBCTs, providing a technical yet accessible understanding of this essential device.\nWhat is a Core Balance Current Transformer (CBCT)? A CBCT is a specialized current transformer designed to detect zero-sequence currents, currents that arise when the sum of the three-phase currents in a balanced system deviates from zero. Unlike conventional current transformers, which measure individual phase currents, a CBCT focuses on the algebraic sum of currents to identify faults.\nKey Features:\nDesign: A ring-shaped toroidal core with a secondary winding, through which all live conductors (e.g., three-phase lines) pass. Function: Acts as a fault detector by monitoring the imbalance in phase currents. Output: Generates a signal proportional to the residual current, which activates protective relays to trip circuit breakers during faults. Working Principle of CBCT 1. Balanced System Operation In a balanced three-phase system, the currents in all three phases ($I_a$, $I_b$, $I_c$) satisfy Kirchhoff’s Current Law (KCL):\n$$I_a + I_b + I_c = 0$$ Under normal conditions, the magnetic fields generated by each phase’s current cancel out due to their opposite directions. This results in zero net magnetic flux in the CBCT’s core.\nGauss’s Law for Magnetism reinforces this:\n$$\\nabla \\cdot \\mathbf{B} = 0$$\nThis law states that magnetic field lines form closed loops, so the flux enclosed within the core must balance out when currents are balanced. Consequently, no voltage is induced in the secondary winding, and the CBCT remains inactive.\n2. Fault Detection via Ampère’s Law During a ground fault or earth leakage, the symmetry of the three-phase system breaks. For instance, if a fault current ($I_f$) flows to ground from one phase:\n$$I_a\u0026rsquo; + I_b + I_c = I_f \\quad (\\text{where } I_a\u0026rsquo; = I_a + I_f)$$\nApplying Ampère’s Circuital Law:\n$$\\oint \\mathbf{B} \\cdot d\\mathbf{l} = \\mu_0 I_{\\text{enc}}$$\nHere, $I_{\\text{enc}} = I_f$, the fault current. The unbalanced current generates a net magnetic flux ($\\Phi$) in the core, proportional to $I_f$:\n$$\\Phi \\propto I_f$$\nThis flux induces an electromotive force (EMF) in the secondary winding via Faraday’s Law:\n$$V_s = -N \\frac{d\\Phi}{dt}$$\nwhere $N$ is the number of secondary turns. The induced voltage drives a current through the connected relay, triggering a circuit breaker to isolate the fault.\nZero-Sequence Current Concept The zero-sequence current ($I_0$) is defined as:\n$$I_0 = \\frac{I_a + I_b + I_c}{3}$$\nIn a balanced system, $I_0 = 0$. During a fault, $I_0$ equals the fault current divided by 3. The CBCT’s primary winding effectively measures this $I_0$, making it sensitive to ground faults even at low current levels.\nDesign and Construction of CBCT Core Material Toroidal Core: Typically made of ferrite or silicon steel to minimize energy loss and maximize flux linkage. Secondary Winding: A multi-turn coil wound on the core, connected to a protective relay or monitoring device. Installation Non-Invasive: Conductors pass through the core’s central aperture without breaking the circuit. Versatility: Can accommodate single-core or multi-core cables, though size limitations exist for large conductors. Applications of CBCT Power Distribution Systems\nProtects transformers, switchgear, and transmission lines from ground faults. Detects leakage currents in residential and industrial networks. Motor Protection\nMonitors large motors and generators for winding insulation failures or ground faults. Renewable Energy Systems\nEnsures safety in solar inverters and wind turbines by detecting ground faults in PV arrays or generator circuits. Industrial Automation\nUsed in PLC systems to safeguard machinery from phase imbalances or earth faults. Residential Safety\nIncorporated into residual current devices (RCDs) to prevent electrocution and fires. Advantages of CBCT High Sensitivity\nDetects fault currents as low as 100 mA, ensuring rapid fault isolation. Simplified Design\nRequires only a single core instead of three separate current transformers, reducing complexity. Non-Invasive Installation\nEasy to install without interrupting power flow; simply clamped around conductors. Cost-Effective\nLower material and labor costs compared to multi-CT setups. Reliability\nOperates over a wide range of frequencies and currents, maintaining accuracy under varying conditions. Limitations of CBCT AC Only\nCannot measure direct current (DC), limiting use in DC systems like battery banks. Conductor Size Constraints\nLarge conductors may exceed the core’s internal diameter, necessitating custom solutions. Multiple Conductors\nLess effective when multiple cables pass through the core, as mutual inductance can distort readings. Calibration Requirements\nMust be matched to the system’s nominal current to avoid false tripping. Conclusion The Core Balance Current Transformer is a cornerstone of modern electrical protection systems. By leveraging fundamental electromagnetic principles, Gauss’s and Ampère’s laws, it provides reliable detection of ground faults and imbalances, safeguarding lives and equipment. While it has limitations, such as AC-only operation and size constraints, its benefits in cost, simplicity, and sensitivity make it indispensable across industries. For engineers and technicians, understanding CBCT’s operation and applications is critical to designing robust, fault-tolerant power systems.\n","date":"2025-04-13T00:00:00Z","permalink":"https://goiw111.github.io/posts/n_3/","section":"posts","tags":["Electrical_Engineering","CBCT_Transformer","Ground_Fault_Protection","Electromagnetic_Principles","Power_System_Safety"],"title":"Core Balance Current Transformer (CBCT): A Comprehensive Overview"},{"categories":null,"contents":"\nIntroduction This project wasn’t just about making music with hardware – it was a hardware detective story. Armed with an ancient Chinese FPGA board and zero documentation, I accepted the challenge to breathe life into forgotten technology. Here’s how I turned frustration into a functional synthesizer!\nOvercoming Buzzer Limitations One of the first problems I encountered was that the passive buzzer couldn\u0026rsquo;t properly reproduce middle C (C4, 262Hz) and lower notes. When attempting to play the classic \u0026ldquo;Do Re Mi\u0026rdquo; scale starting from C4, the buzzer produced weak, distorted sounds with noticeable clicking artifacts rather than clear musical tones.\nWhy Standard Frequencies Failed Physical Constraints of Piezo Buzzers:\nPassive buzzers rely on mechanical vibration, which dampens significantly at lower frequencies The buzzer\u0026rsquo;s resonant frequency was much higher than middle C, causing poor energy transfer Square Wave Limitations:\nLow-frequency square waves (below ~400Hz) created audible \u0026ldquo;clicks\u0026rdquo; between pulses The buzzer\u0026rsquo;s physical response time couldn\u0026rsquo;t keep up with slow oscillations The High-Frequency Workaround By shifting the musical scale up one octave to C5–C6 (523–1047 Hz), we achieved:\nStronger Acoustic Output:\nPiezo elements resonate more efficiently at these frequencies Audible volume increased by approximately 300% compared to middle C attempts Cleaner Waveform Reproduction:\nEliminated the clicking artifacts of low-frequency operation Produced recognizable musical tones instead of distorted pulses Technical Advantages:\nSmaller counter values fit perfectly in our 13-bit registers Reduced timing errors from FPGA clock division This frequency shift became the foundation for all subsequent sound generation in the project, proving that sometimes the solution isn\u0026rsquo;t to fight hardware limitations, but to redesign around them. The resulting tones, while higher-pitched than originally intended, maintained clear musical relationships and demonstrated the FPGA\u0026rsquo;s sound generation capabilities.\nStep 1: How Digital Music Works Square Waves = Sound A square wave is the foundation of digital sound generation. By toggling an FPGA pin between HIGH (3.3V) and LOW (0V) at precise intervals, we create a waveform that a passive buzzer converts into audible sound through mechanical vibration.\nFrequency Formula $$ f_n = \\tfrac { f_c } {N.2}​​ $$\n$f_c​$ : Clock speed after prescaling (5 MHz here). $N$ : Counter value defining the note’s period. Step 2: VHDL Code Walkthrough Complete Code Structure library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; entity buzzer is Port ( clk : in STD_LOGIC; -- 50 MHz clock rst : in STD_LOGIC; -- Active-low reset out_bit : out STD_LOGIC -- Buzzer output ); end buzzer; architecture Behavioral of buzzer is -- Clock divider (50 MHz -\u0026gt; 5 MHz) signal clk_div1 : unsigned(3 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); -- Note frequency counter signal clk_div2 : unsigned(12 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); -- Note duration counter (~3 seconds per note) signal cnt : unsigned(23 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); -- State machine (8 notes) signal state : unsigned(2 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); -- Musical note constants (C5 to C6) constant C5 : integer := 4780; -- 523 Hz constant D5 : integer := 4259; -- 587 Hz constant E5 : integer := 3792; -- 659 Hz constant F5 : integer := 3580; -- 698 Hz constant G5 : integer := 3189; -- 784 Hz constant A5 : integer := 2841; -- 880 Hz constant B5 : integer := 2532; -- 988 Hz constant C6 : integer := 2389; -- 1047 Hz signal current_note : integer range 0 to 8191 := C5; signal out_bit_tmp : std_logic := \u0026#39;0\u0026#39;; begin out_bit \u0026lt;= out_bit_tmp; process(clk, rst) begin if rst = \u0026#39;0\u0026#39; then -- Reset all counters and outputs clk_div1 \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); clk_div2 \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); cnt \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); state \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); out_bit_tmp \u0026lt;= \u0026#39;0\u0026#39;; elsif rising_edge(clk) then -- Clock prescaler (divide by 10) if clk_div1 \u0026lt; 9 then clk_div1 \u0026lt;= clk_div1 + 1; else clk_div1 \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); -- State machine for note generation case state is when \u0026#34;000\u0026#34; =\u0026gt; current_note \u0026lt;= C5; -- Do when \u0026#34;001\u0026#34; =\u0026gt; current_note \u0026lt;= D5; -- Re when \u0026#34;010\u0026#34; =\u0026gt; current_note \u0026lt;= E5; -- Mi when \u0026#34;011\u0026#34; =\u0026gt; current_note \u0026lt;= F5; -- Fa when \u0026#34;100\u0026#34; =\u0026gt; current_note \u0026lt;= G5; -- Sol when \u0026#34;101\u0026#34; =\u0026gt; current_note \u0026lt;= A5; -- La when \u0026#34;110\u0026#34; =\u0026gt; current_note \u0026lt;= B5; -- Si when \u0026#34;111\u0026#34; =\u0026gt; current_note \u0026lt;= C6; -- Do-high when others =\u0026gt; current_note \u0026lt;= C5; end case; -- Note duration counter if cnt \u0026lt; 15_000_000 then -- ~3 seconds at 5 MHz cnt \u0026lt;= cnt + 1; else cnt \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); state \u0026lt;= state + 1; -- Next note end if; -- Frequency generator if clk_div2 \u0026lt; current_note then clk_div2 \u0026lt;= clk_div2 + 1; else clk_div2 \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); out_bit_tmp \u0026lt;= not out_bit_tmp; -- Toggle buzzer end if; end if; end if; end process; end Behavioral; Code Explanation :\nThe VHDL code above generates a square wave for a passive buzzer using an FPGA. A clock prescaler reduces the 50 MHz input to 5 MHz. A state machine cycles through eight musical notes (C5–C6), each defined by a fixed counter value. A duration counter holds each note for ~3 seconds before advancing to the next. A frequency counter toggles the buzzer output (out_bit) at the note’s frequency: when the counter reaches the note’s value (e.g., 4780 for C5), it resets and flips the output. The system resets via an active-low rst signal, initializing all counters and states. The design uses behavioral synthesis, with a single process handling clock edges and state transitions. Each note’s frequency is calculated using the formula fn​=2Nfc​​, where N is the counter value.\nStep 3: Hardware Setup I discovered that there are four clock inputs on the schematic, so I assigned CLK3 (PIN_92).\nand the builtin buzzer is connected to the PIN_94 as output as shown there.\nand the fourth button (PIN_67) will be connected to the reset input.\nFPGA Pin Connections FPGA Pin Component Notes PIN_92 50 MHz Clock Onboard oscillator. PIN_94 Buzzer Connect to a builtin buzzer. PIN_67 Reset Button Active-low (pulled up to 3.3V). Pin Assignment Using .qsf File\nset_global_assignment -name FAMILY Cyclone set_global_assignment -name DEVICE EP1C3T144C8 set_global_assignment -name TOP_LEVEL_ENTITY buzzer set_global_assignment -name ORIGINAL_QUARTUS_VERSION \u0026#34;13.0 SP1\u0026#34; set_global_assignment -name PROJECT_CREATION_TIME_DATE \u0026#34;23:28:34 APRIL 04, 2025\u0026#34; set_global_assignment -name LAST_QUARTUS_VERSION \u0026#34;13.0 SP1\u0026#34; set_global_assignment -name PROJECT_OUTPUT_DIRECTORY output_files set_global_assignment -name ERROR_CHECK_FREQUENCY_DIVISOR 1 set_global_assignment -name MIN_CORE_JUNCTION_TEMP 0 set_global_assignment -name MAX_CORE_JUNCTION_TEMP 85 set_global_assignment -name VHDL_FILE test_2.vhd # Assembler Assignments # ===================== set_global_assignment -name AUTO_RESTART_CONFIGURATION OFF set_global_assignment -name RESERVE_ALL_UNUSED_PINS \u0026#34;AS INPUT TRI-STATED\u0026#34; set_global_assignment -name STRATIX_DEVICE_IO_STANDARD \u0026#34;3.3-V LVTTL\u0026#34; set_global_assignment -name LL_ROOT_REGION ON -section_id \u0026#34;Root Region\u0026#34; set_global_assignment -name LL_MEMBER_STATE LOCKED -section_id \u0026#34;Root Region\u0026#34; set_global_assignment -name DEVICE_FILTER_PIN_COUNT 144 set_location_assignment PIN_92 -to CLK set_location_assignment PIN_94 -to out_bit set_location_assignment PIN_67 -to rst Step 4: Program the FPGA Compile the design and program the FPGA via JTAG using the generated .sof file.\nConclusion: Choose Your FPGA Wisely While this project was a valuable learning experience, I strongly advise against using obscure, outdated FPGAs like the Cyclone EP1C3T144C8. The challenges I faced highlight several key issues:\nOutdated Tools : Quartus II 13.0 is outdated, lacking modern features and support. Modern alternatives like Quartus Prime Lite offer free, updated software with improved debugging tools and simulation capabilities.\nLimited Documentation : Chinese-only documentation can be a significant barrier. Modern FPGA boards come with comprehensive English datasheets and active community support, making troubleshooting and learning much easier.\nIncomplete Schematics : The lack of schematics and pinout information made hardware setup difficult. Contemporary FPGA development boards provide detailed documentation, ensuring a smoother integration process.\nLegacy hardware certainly teaches resilience and problem-solving skills, but modern FPGAs offer significant advantages in terms of ease of use, support, and long-term sustainability. Investing in a well-documented, widely supported FPGA platform will save time, reduce frustration, and enhance your overall project experience. Choose wisely to ensure a successful and enjoyable development journey!\n","date":"2025-03-29T00:00:00Z","permalink":"https://goiw111.github.io/posts/n_2/","section":"posts","tags":["FPGA","HardwareTips","EmbeddedSystems"],"title":"Building a Musical Synthesizer with FPGA and VHDL: A Step-by-Step Guide"},{"categories":null,"contents":"As a master’s student, I rely on Obsidian for organizing my research notes, ideas, and resources—its graph view and local-first approach make it perfect for long-term knowledge management. But when I want to share polished articles, I use Hugo, a fast and flexible static site generator.\nThe problem? Manually converting Obsidian notes into Hugo-ready Markdown was tedious. I needed a way to:\nConvert [[wikilinks]] → [Markdown links](/posts/slug) Transform ![[image.png]] → ![](/images/image.png)and copy images to /static/images Auto-generate title and date in front matter while preserving existing YAML So, I built an Obsidian plugin to automate this process. Here’s how it works, step by step.\nCreate a GitHub repository\nGo to GitHub Create a new public repository named username.github.io, where username is your GitHub username. In my case, this was goiw111.github.io. Step 2: Setting Up Your Hugo Blog\nInstall Hugo macOS/Linux: brew install hugo # macOS sudo apt-get install hugo # Ubuntu/Debian For other operating systems, please refer to Hugo’s installation documentation.\nCreate a New Hugo Site hugo new site username.github.io \u0026amp;\u0026amp; cd username This generates:\nmy_blog/ ├── archetypes/ ├── content/ # Your posts go here ├── static/ # Images/assets └── config.toml # Site settings Add a Theme Example (using Stack): git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack themes/stack This creates/modifies:\nmy_blog/ ├── .gitmodules # \u0026lt;-- New file with submodule config └── themes/stack # \u0026lt;-- Cloned theme Verify .gitmodules File The file should contain: [submodule \u0026#34;themes/stack\u0026#34;] path = themes/stack url = https://github.com/CaiJimmy/hugo-theme-stack.git Configure hugo.toml:\ntheme = \u0026#34;stack\u0026#34; baseURL = \u0026#34;https://yourdomain.com\u0026#34; languageCode = \u0026#34;en-us\u0026#34; paginate = 5 [params] title = \u0026#34;My Blog\u0026#34; description = \u0026#34;Thoughts on tech and life\u0026#34; .... Folder Structure for Obsidian Export Ensure these directories exist: mkdir -p content/posts # Where notes will export to mkdir -p static/images # Where images will copy to Test Locally hugo server -D Visit http://localhost:1313 to see your site.\nstep 3 : Set up GitHub Actions Once your changes are pushed to GitHub, you need to make some adjustments to the settings page. In your GitHub repository, navigate to Settings \u0026gt; Pages.\nUnder Build and Deployment, update the source from Deploy from a branch to GitHub Action, as shown in the screenshot below.\nTo automatically build and deploy your site to GitHub pages, you need to set up a workflow for GitHub Actions. In your local repository, create a new folder called .github/workflows and add hugo.yaml file with the following contents:\n# Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: - main # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.145.0 HUGO_ENVIRONMENT: production TZ: America/Los_Angeles steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v4 with: submodules: recursive fetch-depth: 0 - name: Setup Pages id: pages uses: actions/configure-pages@v5 - name: Install Node.js dependencies run: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34; - name: Cache Restore id: cache-restore uses: actions/cache/restore@v4 with: path: | ${{ runner.temp }}/hugo_cache key: hugo-${{ github.run_id }} restore-keys: hugo- - name: Build with Hugo run: | hugo \\ --cleanDestinationDir \\ --gc \\ --minify \\ --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; \\ --cacheDir \u0026#34;${{ runner.temp }}/hugo_cache\u0026#34; - name: Cache Save id: cache-save uses: actions/cache/save@v4 with: path: | ${{ runner.temp }}/hugo_cache key: ${{ steps.cache-restore.outputs.cache-primary-key }} - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 The above content was taken from Hugo’s documentation. For more information, please refer to Host on GitHub Pages.\nstep 4 : Connect to Obsidian Export Plugin\nfirs clone the plugin to you Vault plugin folder (/path/to/Obsidian Vault/.obsidian/plugins/) from this repo hugo_exporter\ncd your-obsidian-vault/.obsidian/plugins/ git clone https://github.com/goiw111/hugo_exporter.git Enable in Obsidian: Settings → Community Plugins → Enable \u0026#34;Hugo Export\u0026#34; In the plugin settings (Obsidian → Hugo Export):\nPosts Directory: /full/path/to/my_blog/content/posts Images Directory: /full/path/to/my_blog/static/images Open note → Ctrl+P → \u0026ldquo;Export Active Note to Hugo\u0026rdquo;\nVerify Exports\ncd your-hugo-folder hugo server -D # Check at http://localhost:1313 (Optional) Deployment Setup Create a deploy.sh script: #!/bin/sh hugo --minify cd public \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Update\u0026#34; \u0026amp;\u0026amp; git push now run:\nchmod +x deploy.sh ./deploy.sh Now your Hugo blog is ready!\n","date":"2025-03-29T00:00:00Z","permalink":"https://goiw111.github.io/posts/n_1/","section":"posts","tags":["hugo","obsidian","blog"],"title":"From Obsidian Notes to Hugo Blog Posts. My Automated Publishing Workflow"},{"categories":null,"contents":"Hi there! I'm a tech lover whose journey started when I was a kid, tinkering with web development and cybersecurity. Those early days sparked a curiosity about how technology shapes our world—a passion that’s grown over the years and led me to develop over a decade of experience with Linux.\nMy academic adventure began with a Bachelor\u0026rsquo;s in Physics, where I balanced theoretical insights with practical projects, like building a quadcopter drone that combined my interests in electronics and control systems. Today, I’m pursuing a Master\u0026rsquo;s in Electrical Engineering \u0026amp; Embedded Systems at FPL Larache, further merging my diverse skill set.\nThis blog is a space where I share my experiences, projects, and ideas. Whether you\u0026rsquo;re a fellow tech enthusiast or someone looking to learn more about the exciting intersections of hardware, software, and security, I hope you find something here that inspires you.\n","date":"2019-02-28T00:00:00Z","permalink":"https://goiw111.github.io/about/","section":"","tags":null,"title":"About"}]